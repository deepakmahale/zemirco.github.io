<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Express.js | Mirco Zeiss]]></title>
  <link href="http://mircozeiss.com/categories/express-dot-js/atom.xml" rel="self"/>
  <link href="http://mircozeiss.com/"/>
  <updated>2013-10-11T21:04:54+02:00</updated>
  <id>http://mircozeiss.com/</id>
  <author>
    <name><![CDATA[Mirco Zeiss]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GitHub like signup form with AngularJS and Bootstrap v3]]></title>
    <link href="http://mircozeiss.com/github-like-signup-form-with-angularjs-and-bootstrap-v3/"/>
    <updated>2013-08-21T22:37:00+02:00</updated>
    <id>http://mircozeiss.com/github-like-signup-form-with-angularjs-and-bootstrap-v3</id>
    <content type="html"><![CDATA[<p>Building a modern and clean signup form still requires more coding than one might think. <a href="https://github.com/">GitHub</a>
has a simple signup form that I really like. Just three input fields (username, email and password) and you are ready
to go.</p>

<p>In this post we will build a fully featured copy of this signup form. AngularJS manages our frontend and a small Express.js
app takes care of our backend. As an extra gimmick I added password verification to make sure that our users don't
 have typos in their passwords. In the end we have some validation in the frontend and also in our backend. Take a look
 at the <a href="http://mysterious-escarpment-9591.herokuapp.com/signup">final app</a>. If everything was correct you should see a json object with your username, email and the hashed password
 in addition to some extra information. I also uploaded the whole code to GitHub <a href="https://github.com/zeMirco/ng-signup-form">ng-signup-form</a>.</p>

<h3>The layout</h3>

<p>We use the brand new <a href="http://getbootstrap.com/">Bootstrap v3</a> to build our page. Inside a panel component we have a form with
four input fields. The first one is for username, the second one for email and the last two ones are for password and
 password verification.</p>

<p><img src="https://s3.amazonaws.com/mircozeiss.com/signup-form-layout.png" title="Signup form built on top of Bootstrap v3" ></p>

<h3>Backend with Express.js</h3>

<p>Our backend consists of only three routes: <code>GET /signup</code>, <code>POST /signup</code> and <code>POST /signup/check/username</code>. Our main route <code>/</code> redirects
directly to <code>/signup</code> so when you open the page the signup form is immediately shown.</p>

<p>The code for the first route <code>GET /signup</code> looks like the following.</p>

<p><code>js
app.get('/signup', function(req, res) {
  res.render('signup');
});
</code></p>

<p>It simply takes our <code>signup.jade</code> template and renders it. Our second route <code>POST /signup</code> is the target for the signup form. Let's go through the code step by step.
First of all we get the values of the input fields from the request object.</p>

<p><code>js
var username = req.body.username;
var email = req.body.email;
var password = req.body.password;
var verification = req.body.verification;
</code></p>

<p>Afterwards we perform some input validation, check for duplicate username, create a salt and hashed password
and at the end send a response back to the user. Whenever we encounter invalid data we rerender the
<code>signup.jade</code> template with an additional error message to tell the user what went wrong. Let's start with some input validation.</p>

<h4>1. Input validation on the backend</h4>

<p>Although our submit button is disabled as long as we don't have valid values in our input fields, some clever
people will be able to send invalid data to our backend. That's why we have to double check the incoming data
on the server. We have to make sure that none of the fields are empty, the username doesn't contain any
non-url-safe characters, email value is a valid email address and finally that the provided password matches
the verification.</p>

<p>All in all the code looks like this.</p>

<p>```js
var error = null;
// regexp from https://github.com/angular/angular.js/blob/master/src/ng/directive/input.js#L4
var EMAIL_REGEXP = /<sup>[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,6}$/;</sup></p>

<p>// check for valid inputs
if (!username || !email || !password || !verification) {
  error = 'All fields are required';
} else if (username !== encodeURIComponent(username)) {
  error = 'Username may not contain any non-url-safe characters';
} else if (!email.match(EMAIL_REGEXP)) {
  error = 'Email is invalid';
} else if (password !== verification) {
  error = 'Passwords don\'t match';
}</p>

<p>if (error) {
  response.status(403);
  response.render('signup', {</p>

<pre><code>error: error
</code></pre>

<p>  });
  return
}
```</p>

<h4>2. Check for duplicate username</h4>

<p>In a real world app you would query your database to check for duplicate usernames. In this example
I'm using an in-memory array with json data as dummy database. We simply loop through the array to see
if an entry with the requested username already exists.</p>

<p>```js
// dummy db
var dummyDb = [
  {username: 'john', email: 'john@email.com'},
  {username: 'jack', email: 'jack@email.com'},
  {username: 'jim', email: 'jim@email.com'},
];</p>

<p>// check if username is already taken
for (var i = 0; i &lt; dummyDb.length; i++) {
  if (dummyDb[i].username === username) {</p>

<pre><code>response.status(403);
response.render('signup', {
  error: 'Username is already taken'
});
return;
</code></pre>

<p>  }
}
```</p>

<p>Pro tip: Never do the same for duplicate email addresses. Read more about this topic in Troy Hunt's excellent
post <a href="http://www.troyhunt.com/2012/05/everything-you-ever-wanted-to-know.html">Everything you ever wanted to know about building a secure password reset feature</a>.</p>

<h4>3. Create salt and hash password</h4>

<p>Just for completeness and demonstration purpose I included a small function to create a random salt and hash the provided
password. It might help beginners and reminds everyone never to save passwords in plain text to your db.</p>

<p>```js
// create salt and hash password
pass.hash(password, function(err, salt, hash){
  if (err) console.log(err);</p>

<p>  // yeah we have a new user
  var user = {</p>

<pre><code>username: username,
email: email,
salt: salt,
hash: hash,
createdAt: Date.now()
</code></pre>

<p>  };</p>

<p>  // for fully featured example check duplicate email, send verification link and save user to db</p>

<p>  response.json(200, user)</p>

<p>});
```</p>

<p>I used <a href="https://github.com/visionmedia/node-pwd">pwd</a> to generate the salt and hash the password. You need to include the <a href="https://github.com/visionmedia/node-pwd/pull/3/files">pull request</a>
from jlubawy to make this work for node v0.10 and above. An alternative is <a href="https://github.com/ncb000gt/node.bcrypt.js/">bcrypt</a>.</p>

<p>That's it. We're are almost done with our backend. I will explain the third route <code>POST /signup/check/username</code> in the section
<strong>Custom validators</strong>.</p>

<h3>Form validation with AngularJS</h3>

<p>A good starting point for form validation with AngularJS is the section in the guide <a href="http://docs.angularjs.org/guide/forms">about forms</a>.
First of all you might want to tell the browser not to validate your form since we'd like to use AngularJS for that. Simply add <code>novalidate</code>
as an attribute to your form.</p>

<p>In our example we use two of the built in validators namely <code>required</code> and <code>email</code>. <code>required</code> makes sure you really enter some content
into the input fields and <code>email</code> uses a regular expression to verify a correct format of the email address. To show error message whenever one
of those validators returns an error we use Bootstrap's <code>.help-block</code> class in conjunction with the <code>ngShow</code> directive.</p>

<p><code>
span.help-block(ng-show="form.username.$dirty &amp;&amp; form.username.$error.required") Please choose a username
span.help-block(ng-show="form.email.$dirty &amp;&amp; form.email.$error.email") Email is invalid
</code></p>

<p>You might wonder what <code>$dirty</code> is doing in our code. Every form and every form element in the AngularJS world has two states: <code>$pristine</code> and
<code>$dirty</code>. Your form gets the <code>$pristine</code> state on initial page load before you start entering text into the input fields. So before touching your form it is <code>$pristine</code>. As soon as you start
entering values the forms loses this state and gets the <code>$dirty</code> state because you started working with it. AngularJS also provides CSS classes
to allow for different styling of these states <code>.ng-pristine</code> and <code>.ng-dirty</code>. Read more about that topic in the AngularJS docs about <a href="http://docs.angularjs.org/api/ng.directive:form.FormController">FormController</a>.
If we used the same code as above but without <code>form.username.$dirty</code> and <code>form.email.$dirty</code> the span blocks would be visible on page load.</p>

<h4>Custom validators</h4>

<p>Our first custom validator sends a <code>POST</code> request to the server to check if the username is already taken. We will use a similar
structure as GitHub does. They send a request to <code>/signup_check/username</code> and if the username is already taken they respond with
a status of 403 and the message <code>Username already taken</code>. The same goes for usernames that contain invalid characters.</p>

<p><img src="https://s3.amazonaws.com/mircozeiss.com/github-dev-tools-headers.png" title="Chrome dev tools showing request and response headers" ></p>

<p>Here is the code of our Express app.</p>

<p>```js
app.post('/signup/check/username', function(req, res) {
  var username = req.body.username;
  // check if username contains non-url-safe characters
  if (username !== encodeURIComponent(username)) {</p>

<pre><code>res.json(403, {
  invalidChars: true
});
return;
</code></pre>

<p>  }
  // check if username is already taken - query your db here
  var usernameTaken = false;
  for (var i = 0; i &lt; dummyDb.length; i++) {</p>

<pre><code>if (dummyDb[i].username === username) {
  usernameTaken = true;
  break;
}
</code></pre>

<p>  }
  if (usernameTaken) {</p>

<pre><code>res.json(403, {
  isTaken: true
});
return
</code></pre>

<p>  }
  // looks like everything is fine
  res.send(200);
});
```</p>

<p>We first check for non-url-safe characters and afterwards if the username is already taken. If one of those is the case
we send status 403 and some json data back to the client to tell it what went wrong. If everything is fine we simply send
a status of 200 without any data.</p>

<p>On the client side we build a custom directive called <code>unique-username</code>.</p>

<p>```js
app.directive('uniqueUsername', ['$http', function($http) {<br/>
  return {</p>

<pre><code>require: 'ngModel',
link: function(scope, elem, attrs, ctrl) {
  scope.busy = false;
  scope.$watch(attrs.ngModel, function(value) {

    // hide old error messages
    ctrl.$setValidity('isTaken', true);
    ctrl.$setValidity('invalidChars', true);

    if (!value) {
      // don't send undefined to the server during dirty check
      // empty username is caught by required directive
      return;
    }

    // show spinner
    scope.busy = true;

    // send request to server
    $http.post('/signup/check/username', {username: value})
      .success(function(data) {
        // everything is fine -&gt; do nothing
        scope.busy = false;
      })
      .error(function(data) {

        // display new error message
        if (data.isTaken) {
          ctrl.$setValidity('isTaken', false);
        } else if (data.invalidChars) {
          ctrl.$setValidity('invalidChars', false);
        }

        scope.busy = false;
      });
  })
}
</code></pre>

<p>  }
}]);
```</p>

<p>We can use this directive in the same way we did before with <code>required</code> and <code>email</code> validators.</p>

<p><code>js
span.help-block(ng-show="form.username.$dirty &amp;&amp; form.username.$error.isTaken") Username already taken
span.help-block(ng-show="form.username.$dirty &amp;&amp; form.username.$error.invalidChars") Username may not contain any non-url-safe characters
</code></p>

<p>The <code>uniqueUsername</code> directive also shows a spinner while talking to the server. Through <code>ng-show="busy"</code> we can hide and show the spinner.
The icon is taken from the Glyphicons that come with Bootstrap and some CSS makes it spin.</p>

<p>```css
@-webkit-keyframes rotating {
  from {</p>

<pre><code>-webkit-transform: rotate(0deg);
</code></pre>

<p>  }
  to {</p>

<pre><code>-webkit-transform: rotate(360deg);
</code></pre>

<p>  }
}</p>

<p>.rotating {
  float: right;
  position: relative;
  top: -24px;
  right: 10px;
  -webkit-animation: rotating 1s linear infinite;
}
```</p>

<p>Our second custom form validation method checks whether the password and the password verification input fields have exactly the
same values. Again we use a custom directive for that.</p>

<p>```js
app.directive('match', [function () {
  return {</p>

<pre><code>require: 'ngModel',
link: function (scope, elem, attrs, ctrl) {

  scope.$watch('[' + attrs.ngModel + ', ' + attrs.match + ']', function(value){
    ctrl.$setValidity('match', value[0] === value[1] );
  }, true);

}
</code></pre>

<p>  }
}]);
```</p>

<p>To use this directive apply it to the password input field as well as the verification input field.</p>

<p><code>
input.form-control(type="password", name="password", id="password", ng-model="password", required, match="verification")
input.form-control(type="password", name="verification", id="verification", ng-model="verification", required, match="password")
</code></p>

<p>The error message works as expected but only show it when the verification input fields contains a value.</p>

<p><code>
span.help-block(ng-show="form.verification.$dirty &amp;&amp; form.verification.$error.match &amp;&amp; !form.verification.$error.required") Passwords don't match
</code></p>

<p>Last but not least we keep the submit button disabled as long as our form contains validation errors.</p>

<p><code>
input.btn.btn-primary(type="submit", value="Sign up", ng-disabled="form.$invalid")
</code></p>

<h3>Conclusion</h3>

<p>We've built a signup form very similar to the one GitHub uses with an Express.js backend and AngularJS
on the frontend. In addition to the form validators already provided by AngularJS we've implemented two
custom form validators for unique usernames and password verification. Take a look at the final <a href="http://mysterious-escarpment-9591.herokuapp.com/signup">app</a>. Try usernames like
<strong>john</strong>, <strong>jack</strong> and <strong>jim</strong>.</p>

<p>One thing I couldn't achieve is sending invalid usernames and emails back from the server to the client.
So that the input fields already contain the false information and the user just has to correct them. That
doesn't work because AngularJS doesn't allow an invalid email inside an input field of type <code>email</code>. To
better understand the problem take a look at a quick <a href="http://plnkr.co/edit/XzcCA7?p=preview">example</a>. If you've got an idea how to solve this problem
please feel free to comment below or provide an answer to my question at <a href="http://stackoverflow.com/questions/18217916/how-to-init-invalid-email-and-show-in-inputtype-email">stackoverflow</a>. Thank you!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt deployment process with Jade]]></title>
    <link href="http://mircozeiss.com/grunt-deployment-process-with-jade/"/>
    <updated>2013-06-27T19:20:00+02:00</updated>
    <id>http://mircozeiss.com/grunt-deployment-process-with-jade</id>
    <content type="html"><![CDATA[<p>When building web projects you want to concatenate and minify CSS and JavaScript files
before deployment. Instead of having multiple single files you only
have one file with one single request. It also means you have to change the path to the script inside
your <code>.html</code> or <code>.jade</code> file. During development your code often looks like this.</p>

<p>```html</p>

<script src="js/script1.js"></script>


<script src="js/script2.js"></script>


<script src="js/script3.js"></script>


<script src="js/script4.js"></script>


<p>```</p>

<p>For deployment you might want to change this to a single request fetching a minified file.</p>

<p>```html</p>

<script src="js/script.min.js"></script>


<p>```</p>

<p>In this post I will demonstrate three solutions for this problem.</p>

<ol>
<li><code>grunt-usemin</code> with <code>.html</code> files</li>
<li><code>grunt-preprocess</code> with a tmp/ , dev/ and prod/ folder</li>
<li><code>grunt-preprocess</code> with only dev/ and prod/ folder</li>
</ol>


<h3>Meet grunt-usemin</h3>

<p>If you are using plain HTML files <a href="https://github.com/yeoman/grunt-usemin">grunt-usemin</a> is your best friend. In your <code>index.html</code> file
you only have to add two lines of code.</p>

<p>```html</p>

<!-- build:js js/app.js -->


<script src="js/script1.js"></script>


<script src="js/script2.js"></script>


<script src="js/script3.js"></script>


<script src="js/script4.js"></script>


<!-- endbuild -->


<p>```</p>

<p>Add a task for <code>usemin</code> to your <code>Gruntfile.js</code>.</p>

<p><code>js
useminPrepare: {
  html: ['deploy/views/example.html']
},
usemin: {
  html: ['deploy/views/example.html']
}
</code></p>

<p>After running <code>grunt usemin</code> your <code>index.html</code> contains the link to the minified file.</p>

<p>```html</p>

<script src="js/app.js"></script>


<p>```</p>

<p>Unfortunately this doesn't work for <code>.jade</code> files as <code>grunt-usemin</code> spits out HTML code. Therefore
let's look at another solution.</p>

<h3>grunt-preprocess as an alternative</h3>

<p><a href="https://github.com/onehealth/grunt-preprocess">grunt-preprocess</a> doesn't alter your code. It only shows or hides certain blocks depending
on various settings. You can use it in HTML, JavaScript, CSS, C, Java, etc.</p>

<h4>Code in tmp/ and deploy to dev/ and prod/</h4>

<p>One way to set up your app structure would be coding in a tmp/ folder and deploying to a development folder for testing and
to a production folder for final deployments.</p>

<p><code>
/tmp
/dev
/prod
</code></p>

<p>With this structure you can use <code>grunt-preprocess</code> as follows.</p>

<p>```</p>

<!-- @if production=false -->


<p>script(src="/javascripts/script1.js")
script(src="/javascripts/script2.js")
script(src="/javascripts/script3.js")</p>

<!-- @endif -->




<!-- @if production=true -->


<p>script(src="/javascripts/script.min.js")</p>

<!-- @endif -->


<p>```</p>

<p>You can't work with this file directly since it loads your single script files and also the minified file. Include
the tasks for building dev and prod versions into your <code>Gruntfile.js</code>.</p>

<p>```js
preprocess: {
  // production version with min script
  prod: {</p>

<pre><code>src: ['deploy/views/layout-wrong.jade'],
options: {
  inline: true,
  context: {
    production: true  // important
  }
}
</code></pre>

<p>  },
  // development version
  dev: {</p>

<pre><code>src: ['deploy/views/layout-wrong.jade'],
options: {
  inline: true,
  context: {
    production: false  // important
  }
}
</code></pre>

<p>  }
}
```</p>

<p>The important part is the <code>context</code> where you can set the <code>production</code> variable to <code>true</code> or <code>false</code>.
When running <code>grunt preprocess:dev</code> you'll get</p>

<p><code>
script(src="/javascripts/script1.js")
script(src="/javascripts/script2.js")
script(src="/javascripts/script3.js")
</code></p>

<p>compared to running <code>grunt preprocess:prod</code></p>

<p><code>
script(src="/javascripts/script.min.js")
</code></p>

<p>This setup adds extra overhead to your project folder and requires recompiling on every change. To neglect recompiling
you could add a <strong>watch</strong> task to your <code>Gruntfile</code> so the files are recreated every time you make changes. Still it is not an ideal
solution.</p>

<h4>Code in dev/ and deploy to /prod</h4>

<p>Here is a neat little trick that allows working with your development files and deploying
files that contain the links to minified assets. So you don't have to work in a tmp folder and
build files either for your development or your deployment folder.</p>

<p>```
  <!-- @exclude -->
  script(src="/javascripts/script1.js")
  script(src="/javascripts/script2.js")
  script(src="/javascripts/script3.js")
  <!-- @endexclude --></p>

<!-- @exclude -->


<p>//- <!-- @endexclude -->
  script(src="/javascripts/script.min.js")
```</p>

<p>The preprocess task in your Gruntfile looks like this</p>

<p>```js
preprocess: {
  inline: {</p>

<pre><code>src: ['deploy/views/layout.jade'],
options: {
  inline: true
}
</code></pre>

<p>  }
}
```</p>

<p>How does this work? Well, first of all if you start your Express app and navigate to the index page
you will only see</p>

<p>```html</p>

<script src="http://mircozeiss.com/javascripts/script.min.js"></script>


<p>```</p>

<p>It is not documented but Jade won't complain when you use plain HTML comments. That allows us to use this
nifty trick. The line <code>script(src="/javascripts/script.min.js")</code> is commented out because of the <code>//-</code> one line
above. Therefore you can work with this file during development and <code>script.min.js</code> won't be called.
Now comes the magic: if you build your deployment files everything between <code>&lt;!-- @exclude --&gt;</code> and
<code>&lt;!-- @endexclude --&gt;</code> is removed from the file. That means your single script files don't exist anymore
and also the comment <code>//-</code> above the minified script will be removed. That means the line <code>script(src="/javascripts/script.min.js")</code>
is now active and calls your minified file.</p>

<p>To make this work keep an eye on the indentation of your <code>layout.jade</code> file. The following won't work.</p>

<p>```</p>

<!-- @exclude -->


<p>script(src="/javascripts/script1.js")
script(src="/javascripts/script2.js")
script(src="/javascripts/script3.js")</p>

<!-- @endexclude -->




<!-- @exclude -->


<p>//- <!-- @endexclude -->
  script(src="/javascripts/script.min.js")
```</p>

<p>It produces this output in Jade.</p>

<p><code>jade
script(src="//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js")
  script(src="/javascripts/script.min.js")
</code></p>

<p>Compiled to HTML it looks like this and won't execute any code</p>

<p>```html</p>

<script src="...">script(src="/javascripts/script.min.js")</script>


<p>```</p>

<h3>Conclusion</h3>

<p>Replacing links to your assets for deployment is easy. When dealing with <code>html</code> files
use <a href="https://github.com/yeoman/grunt-usemin">grunt-usemin</a>. Otherwise give <a href="https://github.com/onehealth/grunt-preprocess">grunt-preprocess</a> a try. You can find an example Express
app with all the relevant grunt tasks at <a href="https://github.com/zeMirco/grunt-jade-preprocess">github</a>. To get the app ready for deployment run the following
commands.</p>

<p><code>bash
grunt deploy
cd deployment
node app.js
</code></p>

<p>Now open your browser, navigate to <a href="http://localhost:3000">localhost:3000</a> and take a look at
the source code. You should see only one JavaScript file <code>script.min.js</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using CSRF protection with Express and Angular]]></title>
    <link href="http://mircozeiss.com/using-csrf-with-express-and-angular/"/>
    <updated>2013-05-19T19:20:00+02:00</updated>
    <id>http://mircozeiss.com/using-csrf-with-express-and-angular</id>
    <content type="html"><![CDATA[<p>In this post I'll demonstrate how to use CSRF protection for Express and Angular apps. Both frameworks have CSRF protection
built in but don't understand each other without manual adjustments.</p>

<p>Express is built on top of the <a href="http://www.senchalabs.org/connect/">connect</a> framework which has a native <a href="http://www.senchalabs.org/connect/csrf.html">csrf</a> middleware. It generates a random string token
that is unique for each user. The token is saved in the user's session on the server. On every request which mutates state,
usually <code>PUT</code>, <code>POST</code> and <code>DELETE</code> requests, the middleware validates whether the CSRF token sent from the client is the
same as the token stored in the user's session on the server. If it isn't the client gets the answer <code>403 Forbidden</code>. The following is taken from the docs and describes where the middleware is looking for the token.</p>

<blockquote><p>The default value function checks req.body generated by the bodyParser() middleware, req.query generated by query(), and the "X-CSRF-Token" header field.</p></blockquote>

<p>Angular also has CSRF features built into its $http service.</p>

<blockquote><p>When performing XHR requests, the $http service reads a token from a cookie called XSRF-TOKEN and sets it as the HTTP header X-XSRF-TOKEN</p></blockquote>

<p>Both frameworks offer CSRF protection. To make them work together we have to make some adjustments. Follow the steps below to make CSRF work for your next app</p>

<ol>
<li>Add CSRF middleware to your Express app</li>
<li>Tell the middleware to use the right token</li>
<li>Use custom middleware to set a cookie for Angular</li>
<li>Use Angular $http library for XHR requests</li>
</ol>


<h3>1. Adding CSRF middleware to an Express app</h3>

<p>In the first step we have to add the CSRF middleware to our app. As it requires sessions we also have to
add some extra session middleware. You don't have to install anything because they come with Express.</p>

<p><code>js
app.use(express.cookieParser('your secret here'));
app.use(express.cookieSession());
app.use(express.csrf());
</code></p>

<h3>2. Telling CSRF middleware to use the right token</h3>

<p>As mentioned earlier the default CSRF middleware looks in <code>req.body</code>, <code>req.query</code> and the <code>X-CSRF-Token</code> header for the token.
Angular uses none of the methods but instead its own header <code>X-XSRF-TOKEN</code>. Therefor we have to tell Express where to look
for the token delivered by Angular. Create a new function that returns this token from the <code>request</code> object.</p>

<p>```js
var csrfValue = function(req) {
  var token = (req.body &amp;&amp; req.body._csrf)</p>

<pre><code>|| (req.query &amp;&amp; req.query._csrf)
|| (req.headers['x-csrf-token'])
|| (req.headers['x-xsrf-token']);
</code></pre>

<p>  return token;
};
```</p>

<p>The function above is the default function taken from connect. I just added the last line <code>req.headers['x-xsrf-token']</code>.
It still accepts the other methods but also finds the incoming token from Angular. Now pass this function to the CSRF middleware from step 1.</p>

<p><code>js
app.use(express.csrf({value: csrfValue}));
</code></p>

<p>Cool, Express can now find the token sent by Angular. One thing that is missing is sending the token from our Express server
to our Angular client.</p>

<h3>3. Using custom middleware to set a cookie for Angular</h3>

<p>Angular's $http library reads the token from the <code>XSRF-TOKEN</code> cookie. We therefore have to set this cookie and send it to
the client. Setting a cookie in Express is done via the <code>res.cookie('name', 'value')</code> function. The name is obviously <code>XSRF-TOKEN</code>.
The value is read from the user's session. The key <code>req.session._csrf</code> is automatically generated by the csrf middleware.</p>

<p><code>js
app.use(function(req, res, next) {
  res.cookie('XSRF-TOKEN', req.session._csrf);
  next();
});
</code></p>

<h3>4. Using Angular $http library for XHR requests</h3>

<p>We now have everything in place to use Angular's $http library without further adjustments. A simple
controller could look like the following</p>

<p>```js
var myApp = angular.module('myApp',[]);</p>

<p>myApp.controller('csrfCtrl', ['$scope', '$http', function($scope, $http) {</p>

<p>  $scope.submit = function() {</p>

<pre><code>$http.post('/', {value: $scope.value})
  .success(function(data) {
    $scope.answer = data
  })
  .error(function() {
    console.log('err')
  })
</code></pre>

<p>  }</p>

<p>}]);
```</p>

<p>No adjustments are need on the client and your code should work as is.</p>

<p><img src="https://s3.amazonaws.com/mircozeiss.com/csrf-express-angular.png" title="CSRF example for Express and Angular" ></p>

<h3>Conclusion</h3>

<p>As you've seen adding CSRF protection to an app built with Express and Angular is really simple. There shouldn't be
any reason not to use this technique for your next app. It adds another layer of security. The underlying principles can also
be applied to apps built with a different stack. Reading their documentations is always a good start.</p>

<p>You can find the code at GitHub <a href="https://github.com/zeMirco/csrf-express-angular">zeMirco/csrf-express-angular</a> and a running example at Heroku <a href="http://arcane-headland-6078.herokuapp.com/">http://arcane-headland-6078.herokuapp.com/</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Not using email as the primary key with Mozilla Persona]]></title>
    <link href="http://mircozeiss.com/not-using-email-as-the-primary-key-with-mozilla-persona/"/>
    <updated>2013-05-13T20:53:00+02:00</updated>
    <id>http://mircozeiss.com/not-using-email-as-the-primary-key-with-mozilla-persona</id>
    <content type="html"><![CDATA[<p>Based on the feedback for my last post <a href="http://mircozeiss.com/mozilla-persona-example-app-with-express-and-couchdb/">Mozilla Persona example app with Express and CouchDB</a>
I made some small but quite important changes in the architecture of my app.</p>

<p><a href="http://fmarier.org/">Francois Marier</a> suggested that we shouldn't use our users' email addresses as the primary key
in our db. That's also what Mozilla's <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Persona/The_implementor_s_guide/Enabling_users_to_change_their_email_address?redirectlocale=en-US&amp;redirectslug=Persona%2FThe_implementor_s_guide%2FEnabling_users_to_change_their_email_address">implementer's guide</a> is telling. So
I took the code from my last post and refactored everything. Each user is now identified by a unique key and not anymore by his email address.
You can find the current version of the example app at GitHub <a href="https://github.com/zeMirco/mozilla-persona-express-couchdb">mozilla-persona-express-couchdb</a>.</p>

<h3>Using views to find users</h3>

<p>In the first version of my app I used the email as the primary key. Getting a user from db was as simple as a <code>GET</code> request
with the appropriate email address. Now that I don't have the email as the primary key anymore and every user is stored under
a random string, we have to use a simple <strong>CouchDB view</strong>.</p>

<p>```js
"views": {
  "byEmail": {</p>

<pre><code>"map": "function(doc){
  if (doc.type === 'user') {
    emit(doc.email, doc)
  }
}"
</code></pre>

<p>  }
}
```</p>

<p>Every user document looks like the following</p>

<p><code>js
{
   "_id": "3115b40189b7dfa4d007ff7fc8536af4",
   "_rev": "2-359ee1c1e888690c9c6468b55fa48fa7",
   "type": "user",
   "email": "mirco.zeiss@gmail.com",
   "username": "zeMirco"
}
</code></p>

<p>Combined with the <strong>view</strong> from above gives us the following table, which we can query with the <code>email</code> as <code>key</code>.</p>

<table class="table table-striped table-hover table-condensed table-bordered">
  <thead>
    <tr>
      <th>Key</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“test@mockmyid.com”</td>
      <td>{...}</td>
    </tr>
    <tr>
      <td>“mirco.zeiss@gmail.com”</td>
      <td>{...}</td>
    </tr>
  </tbody>
</table>


<h3>Querying the view</h3>

<p>In the first version of the app I used a simple <code>GET</code> request to retrieve the user object.</p>

<p><code>js
db.get(email, function(err, doc) {
  ...
})
</code></p>

<p>I changed those lines as we have to query the view now.</p>

<p><code>js
db.view('users', 'byEmail', {key: email}, function(err, body) {
  ...
})
</code></p>

<p>Unfortunately that means we can't use the <a href="http://eclipsesource.com/blogs/2013/03/01/use-your-head-checking-couchdb-document-existence/"><code>HEAD</code> request</a> to check for document existence.
This is now done by checking the amout of <code>rows</code> we get back as an answer.</p>

<h3>Let the user change his email address</h3>

<p>With the new architecture in place users are able to change their email addresses as described in Mozilla's <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Persona/The_implementor_s_guide/Enabling_users_to_change_their_email_address?redirectlocale=en-US&amp;redirectslug=Persona%2FThe_implementor_s_guide%2FEnabling_users_to_change_their_email_address">Implementer's Guide</a>.
I haven't yet implemented this feature but will do so in the near future and write about my experiences. So stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mozilla Persona example app with Express and CouchDB]]></title>
    <link href="http://mircozeiss.com/mozilla-persona-example-app-with-express-and-couchdb/"/>
    <updated>2013-05-03T20:25:00+02:00</updated>
    <id>http://mircozeiss.com/mozilla-persona-example-app-with-express-and-couchdb</id>
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Persona">Mozilla Persona</a> gained a lot of attention recently.
The developers have released <a href="http://identity.mozilla.com/post/47541633049/persona-beta-2">Beta 2</a> at the
beginning of last month and aim to bring Persona to <a href="https://blog.mozilla.org/beyond-the-code/2013/04/09/persona-beta2/">half of the worldwide Internet population</a> in the near future.</p>

<p>Although Mozilla has a <a href="https://developer.mozilla.org/en-US/docs/Persona/Quick_Setup">quick setup guide</a> to demonstrate the basic implementation
it is not as trivial to create a fully featured web app with <a href="http://www.adambarth.com/papers/2008/barth-jackson-mitchell-b.pdf">CSRF protection</a>,
<a href="https://developer.mozilla.org/en-US/docs/Security/CSP">Content Security Policy</a> and database in the backend. That's why I wrote
this simple example application to learn more about the system and help others to get started.</p>

<p>The app is built on the following open source stack</p>

<ul>
<li><a href="http://couchdb.apache.org/">CouchDB</a> hosted at <a href="https://cloudant.com/">Cloudant</a></li>
<li><a href="https://github.com/dscape/nano">nano</a></li>
<li><a href="http://expressjs.com/">Express</a></li>
<li><a href="https://github.com/mikeal/request">Request</a></li>
<li><a href="http://jquery.com/">jQuery</a></li>
<li><a href="http://twitter.github.io/bootstrap/">Bootstrap</a></li>
</ul>


<p>To see the demo visit <a href="http://mysterious-coast-9759.herokuapp.com/">mysterious-coast-9759.herokuapp.com</a>. The code is available at
GitHub <a href="https://github.com/zeMirco/mozilla-persona-express-couchdb/">mozilla-persona-express-couchdb</a>.</p>

<p><img src="https://s3.amazonaws.com/mircozeiss.com/mozilla-persona-example.png" title="Mozilla Persona example app with Express and CouchDB" ></p>

<h3>Related projects</h3>

<p>Several other examples already exist. Take a look at</p>

<ul>
<li><a href="https://github.com/mozilla/123done">123done</a></li>
<li><a href="https://github.com/lloyd/node.js-persona-example">node.js-persona-example</a></li>
<li><a href="https://github.com/lloyd/myfavoritebeer.org">myfavoritebeer.org</a></li>
<li><a href="https://github.com/mozilla/browserid-cookbook/tree/master/node-express">browserid-cookbook</a></li>
</ul>


<p>They were the foundation and inspiration for my own project. Without them I couldn't have done it. Therefore, thanks to the authors!
Especially to <a href="http://lloyd.io/">Lloyd Hilaiel</a>, <a href="http://fmarier.org/">Francois Marier</a> and <a href="https://shanetomlinson.com/">Shane Tomlinson</a>.</p>

<p>However, all of the examples were missing some features I'd like to see. These are</p>

<ul>
<li>proper DB implementation</li>
<li>CSRF protection</li>
<li>Content Security Policy (CSP)</li>
<li>cookie for <code>loggedInUser</code> variable</li>
<li>use of request module (imho makes code easier to read)</li>
<li>simplicity</li>
</ul>


<p>So I tried to take the best parts from the above examples and throw them together in my own app.</p>

<h3>Getting started</h3>

<p>I won't cover the basic implementation. Read more about those steps in <a href="https://developer.mozilla.org/en-US/docs/Persona/Quick_Setup">quick setup</a>.
I'd like to focus more on the advanced stuff.</p>

<p>Let's start by implementing our database. We want to save our users identified by their email address and an additional property, which is the username.
As we are using CouchDB a sample document looks like the following.</p>

<p><code>js
{
   "_id": "mirco.zeiss@gmail.com",
   "_rev": "31-a51c569f771348de72f06a0886b51ab0",
   "username": "zeMirco"
}
</code></p>

<p>Every time a user logs in with Persona <code>navigator.id.request()</code> is called and a <code>POST</code> request to <code>/auth/login</code> is made.</p>

<p>```js
onlogin: function(assertion) {
  var token = $('#token').val();
  $.post('/auth/login', {assertion: assertion, _csrf: token}, function(data) {</p>

<pre><code>window.location.reload();
</code></pre>

<p>  });
}
```</p>

<p>We'll get to the <code>token</code> and <code>_csrf</code> stuff later in this post. On the server the assertion is verified by posting it and the <code>audience</code> to Mozilla.
As soon as we get a valid answer back we have to do the following:</p>

<ol>
<li>Check if the email is stored in our db</li>
<li>If not create a new user with an empty <code>username</code> property and save him to the db</li>
<li>If the email is already present in our db do nothing (we have a returning user)</li>
</ol>


<p>Unfortunately Persona doesn't tell us whether the user is a new or existing one. That's why we have to check for existence on every login. CouchDB provides a handy feature to check for document existence. Instead of making a full <code>GET</code> request with the email as <code>key</code>
we can simply use a lightweight <code>HEAD</code> request. Read more about this trick at <a href="http://eclipsesource.com/blogs/2013/03/01/use-your-head-checking-couchdb-document-existence/">Use your head checking CouchDB document existence</a>.
If we get back an error with status code <code>404</code> we have a new user. Therefore save him to db.</p>

<p>```js
db.head(email, function(err, body, header) {
  if (err) console.log(err);
  if (err &amp;&amp; err.status_code === 404) {</p>

<pre><code>// email is not in db
var doc = {
  username: ''
};
db.insert(doc, email, function(err, body) {
  if (err) console.log(err);
  resp.send(200);
})
</code></pre>

<p>  } else {</p>

<pre><code>// email is already stored in db
resp.send(200);
</code></pre>

<p>  }
});
```</p>

<p>Sweet, we can now save our users to db and differentiate between new and existing ones. Problem is we somehow have to remember who is logged in and who isn't.
We don't want ours users to make the login call on every request. Therefore we have to use <strong>sessions</strong>.</p>

<h3>Cookie session</h3>

<p>Express offers cookie based session support via the <a href="http://www.senchalabs.org/connect/">connect</a> <a href="http://www.senchalabs.org/connect/cookieSession.html">cookieSession</a> middleware.
You could also use Mozilla's own implementation <a href="https://github.com/mozilla/node-client-sessions">node-client-sessions</a> or some key value stores like Redis.
Read more about the pros and cons of cookies vs stores at <a href="https://hacks.mozilla.org/2012/12/using-secure-client-side-sessions-to-build-simple-and-scalable-node-js-applications-a-node-js-holiday-season-part-3/">Using secure client-side sessions to build simple and scalable Node.JS applications</a>.</p>

<p>To enable cookie sessions in Express add the following middleware to your config.</p>

<p><code>js
// built in middleware
app.use(express.cookieParser('your secret here'));
app.use(express.cookieSession());
</code></p>

<p>You can now create sessions on login <code>req.session.email = email</code> and destroy them on logout <code>req.session = null</code>. Our users can also
visit the <code>/profile</code> route which is protected and not accessible for users without any valid session.</p>

<p>```js
// middleware to restrict access to internal routes like /profile
function restrict(req, res, next) {
  if (req.session.email) {</p>

<pre><code>next();
</code></pre>

<p>  } else {</p>

<pre><code>res.redirect('/');
</code></pre>

<p>  }
}</p>

<p>// use the middleware in your routes
app.get('/profile', restrict, profile.get);
```</p>

<h3>Content Security Policy</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Security/CSP">Content Security Policy</a> (simply said) tells the browser to use JavaScript (and images, style sheets, frames, etc.)
only from your own domain while forbidding inline script and script from third party URLs. It adds another layer of security against XSS attacks.</p>

<p><a href="https://github.com/evilpacket/helmet">Helmet</a> is a great middleware to set CSP headers in Express. It also offers several other layers of security.
In my app I'll write the headers by hand as it only requires a few lines of code.</p>

<p>Check for browser support and implementation at <a href="http://caniuse.com/#feat=contentsecuritypolicy">caniuse#contentsecuritypolicy</a>.
Firefox and IE10 need the <code>X-Content-Security-Policy</code> header while Safari and Chrome need <code>X-WebKit-CSP</code>.</p>

<p>```js
var policy =  "default-src 'self';" +</p>

<pre><code>          "frame-src 'self' https://login.persona.org;" +
          "script-src 'self' 'unsafe-inline' https://login.persona.org;" +
          "style-src 'self' 'unsafe-inline'";
</code></pre>

<p>app.use(function(req, res, next) {
  // Firefox and Internet Explorer
  res.header("X-Content-Security-Policy", policy);
  // Safari and Chrome
  res.header("X-WebKit-CSP", policy);
  // continue with next middleware
  next();
});
```</p>

<p>In theory adding <code>'unsafe-inline'</code> shouldn't be necessary but I got errors in Chrome caused by jQuery. Maybe they are related to <a href="http://bugs.jquery.com/ticket/13507">jQuery bug #13507</a>.
You can verify the headers in the browser's development tools.</p>

<p><img src="https://s3.amazonaws.com/mircozeiss.com/persona-csp.png" title="Content Security Policy Headers" ></p>

<h3>CSRF protection</h3>

<p>A great explanation for Cross-Site Request Forgery is the paper <a href="http://www.adambarth.com/papers/2008/barth-jackson-mitchell-b.pdf">Robust Defenses for Cross-Site Request Forgery</a>.
Express provides a built in middleware <a href="http://www.senchalabs.org/connect/csrf.html">csrf</a> which makes the use of CSRF very easy.</p>

<p>Our own custom middleware makes the <code>token</code> variable available to all our views and we can use it whenever we have to change the state on the server.</p>

<p><code>js
app.use(function(req, res, next) {
  res.locals.token = req.session._csrf;
  next();
});
</code></p>

<p>That's usually done by adding a hidden input field to the forms.</p>

<p><code>jade
form#login.navbar-form.pull-right
  input#token(type="hidden", name="_csrf", value=token)
  button.btn(type="submit") Login
</code></p>

<p>The token is sent to the server and <code>app.use(express.csrf());</code> checks if it is equal to <code>req.session._csrf</code>. If it isn't Express throws a <code>403</code> error.
We not only have to include the token in forms but also when we make ajax requests.</p>

<p><code>js
var token = $('#token').val();
$.post('/auth/login', {assertion: assertion, _csrf: token}, function(data) {
  window.location.reload();
});
</code></p>

<p>That explains the additional <code>_csrf</code> key.</p>

<h3>Sending <em>loggedInUser</em> from server to client JavaScript</h3>

<p>The <a href="https://developer.mozilla.org/en-US/docs/DOM/navigator.id.watch"><code>navigator.id.watch</code></a> function requires the <code>loggedInUser</code> parameter,
which tells Persona what you believe about the user's state.</p>

<p><a href="https://github.com/mozilla/123done/blob/master/static/js/123done.js#L42-L44">123done</a> makes a GET request to <code>/api/auth_status</code> in order to get <code>loggedInUser</code></p>

<p><code>js
$.get('/api/auth_status', function(data) {
  loggedInEmail = JSON.parse(data).logged_in_email;
  ...
});
</code></p>

<p>and the server responds with the current session.</p>

<p>```js
app.get('/api/auth_status', function(req, res) {
  res.send(JSON.stringify({</p>

<pre><code>logged_in_email: req.session.user || null,
</code></pre>

<p>  }));
});
```</p>

<p><a href="https://github.com/lloyd/node.js-persona-example/blob/master/views/index.ejs#L15">node.js-persona-example</a> uses inline JavaScript
and puts the variable via <a href="https://github.com/visionmedia/ejs">ejs</a> directly into the view.</p>

<p><code>html
navigator.id.watch({
  loggedInUser: &lt;%- JSON.stringify(email) %&gt;,
  ...
})
</code></p>

<p>The server renders the view with the local variable <code>email</code> with holds the current session.</p>

<p><code>js
app.get('/', function(req, res) {
  res.render('index.ejs', { email: req.session.email || null });
});
</code></p>

<p><a href="https://github.com/lloyd/myfavoritebeer.org/blob/master/static/js/main.js#L135-L138">myfavoritebeer.org</a> also makes a GET request. This time to <code>/api/whoami</code>.</p>

<p><code>js
$.get('/api/whoami', function (res) {
  if (res === null) loggedOut();
  else loggedIn(res, true);
}, 'json');
</code></p>

<p>The server responds with the email from the current session and the corresponding image from <a href="https://www.libravatar.org/">Libravatar</a>.</p>

<p>```js
app.get("/api/whoami", function (req, res) {
  if (req.session &amp;&amp; typeof req.session.email === 'string') {</p>

<pre><code>respondWithUserInfo(req, res);
</code></pre>

<p>  } else {</p>

<pre><code>return res.json(null);
</code></pre>

<p>  }
});</p>

<p>function respondWithUserInfo(req, res) {
  libravatar.url({email: req.session.email, size: 32, http: false},</p>

<pre><code>function (error, avatar) {
  if (error) {
    return res.json({'email': req.session.email, 'avatar': ''});
  }
  return res.json({'email': req.session.email, 'avatar': avatar});
});
</code></pre>

<p>}
```</p>

<p>Last but not least <a href="https://github.com/mozilla/browserid-cookbook/blob/master/node-express/views/layout.jade#L17-L22">browserid-cookbook</a>
uses inline script (this time with Jade instead ejs) to pass the current user to the frontend.</p>

<p>```jade
if user
  script</p>

<pre><code>var loggedInUser = '#{user}';
</code></pre>

<p>else
  script</p>

<pre><code>var loggedInUser = null;
</code></pre>

<p>```</p>

<p>The server sets the local variable <code>loggedInUser</code> from the current session.</p>

<p>```js
exports.index = function(req, resp){
  resp.render('index', {</p>

<pre><code>title: 'Express', 
user: req.session.email, 
csrf: req.session._csrf 
</code></pre>

<p>  })
};
```</p>

<p>In summary two examples use inline script and two use extra GET requests. What's the better implementation?</p>

<p>In my opinion both aren't perfect. Inline script is probably the easiest but worst solution, as it won't work with a strict Content Security Policy.
An extra GET request costs time and you have to implement an additional route on your server. That's why I chose a third solution. I use cookies to send
the current user from our backend to the frontend. Mozilla also recommends this way.</p>

<blockquote><p>... you might examine the browser's cookies to determine who is signed in.</p></blockquote>

<p>We can set the cookie via a custom middleware. If the user isn't logged in and doesn't have a valid session no cookie is needed.</p>

<p>```js
app.use(function(req, res, next) {
  if (req.session.email) {</p>

<pre><code>res.cookie('email', req.session.email);
</code></pre>

<p>  }
  next();
});
```</p>

<p>On the client we can read the cookie via the awesome <a href="https://github.com/carhartl/jquery-cookie">jquery-cookie</a> plugin.</p>

<p><code>js
var email = $.cookie('email') || null;
</code></p>

<p>Cookies have the advantage that they save the extra request to the server and don't require inline script.</p>

<h3>Conclusion</h3>

<p>A few more steps than just the quick setup are needed to build a full featured web app based on Mozilla Persona. However it isn't rocket science and I've learned a lot while developing this app.
Persona is a great technology and admins will have less to worry about, as no passwords are stored in the db.</p>

<p>I'm sure my example is far from being perfect so if you see any mistakes or find room for improvements please open an <a href="https://github.com/zeMirco/mozilla-persona-express-couchdb/issues">issue</a> at GitHub.</p>
]]></content>
  </entry>
  
</feed>
